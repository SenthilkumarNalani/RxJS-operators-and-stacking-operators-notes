// Basics: https://www.udemy.com/course/rxjs-and-observables/learn/lecture/26322540#overview
// So far, we have seen how the Observables work and how can we easily create them using various sources.
// Now it's the time to learn about the Pipeable Operators.
// In short, they are one of the most powerful features of RxJS as they allow us to transform the notifications emitted by an Observable in countless ways. We can filter and map the emitted values, provide a fallback for error scenario, or even start new Inner Subscriptions to some other Observables.
// In other words, the Pipeable Operators enable us to write complex asynchronous logic with just a few lines of code, making it easy to read and work with.

// some operators we cover:
// Filter pipeable operator: It is similar to the 'filter' operator in JavaScript arrays. The general idea is the same, however, instead of filtering the items in an array, the 'filter' Pipeable Operator filters the emitted values and passes them through or not.

// Map pipeable operator: Once again, it's a stream world counterpart of the 'map' known from JavaScript arrays. This operator takes the emitted value and can transform it into some other value. Very useful to extract some single property nested inside of a more complex object.

// Tap pipeable operator: It allows us to cause side effects without changing the notifications. Among other things, it is useful for debugging and learning purposes. For example, we can console log the emitted values at any stage of the pipeline of operators if we use multiple operators stacked.

// debounceTime pipeable operator: It is useful if the source Observable emits a lot of values and then settles down. This is often used with the input from the user. An example can be a scenario in which the user types in some value into an input field and the recalculations triggered by each keystroke take some time, are slow. By using this operator, we can debounce the events coming from this input and let the user type in the value without slowdown. Then, after the user stops typing, the recalculation code would be triggered only once.

// catchError pipeable operator: The Pipeable Operators can also use a completely new Observable as its output. An example of such operator is the 'catchError' operator. When an error notification is emitted by the source Observable, this operator will not pass this error through, but instead it will use the provided fallback Observable as the new source.

// Flattening pipeable operators: Flattening Operators, which we've got a few of in RxJS, such as 'concatMap', 'switchMap', 'mergeMap' and 'exhaustMap'. The general idea behind them is the same. They take the incoming emitted value and map it into another Observable. And the 'concatMap' variant is the safest choice if you're not sure which one to choose. However, for the most part, they work the same. And we'll also talk about 'switchMap' and 'mergeMap' and compare the differences between all of them.

// Note: The operators mentioned here are just a small part of what's available in RxJS. We've chosen these as they make a great starting set and show how different the operators can be. Some change the emitted value, some pass it further or not, others work in the time domain and others react to the error notifications or even start new Inner Subscriptions.

// Operator stacking:

// Normal scenario: source observable to observer
// Let's start with a regular Subscription scenario where we don't use any Pipeable Operators, just as we did so far. So, we have some source Observable to which we can subscribe and the logic inside of this Observable will be able to emit various notifications which will reach our Observer.

// case 1 - With one pipeable operator: source observable + operator --> newly made observable to observer
// Let's now say that we'd like to add a Pipeable Operator between our source Observable and Observer. Let's see how can we do this and how it works. Once again, we have some source Observable, and this time we will add a Pipeable Operator to it. So, an operator takes an Observable as input, which in this case is our source Observable above, and returns a newly made Observable. So, instead of changing the original source Observable, the operator creates a new one which is extended with the logic introduced by this operator.So, in the case we can see here, we have the source Observable to which we've applied an operator. This created a new Observable with the extended logic. Now, we can subscribe to this new Observable. So if we subscribe to such Observable, the operator's logic will be run first, which will underneath subscribe to the source Observable, which in effect will run its logic and start emitting notifications. Every time the source Observable emits something, this notification will first reach the operator's logic before reaching our Observer. So the operator's logic will decide whether this notification will reach our Observer or not. Also, it can change the emitted notifications in any way it wants or even produce its own emissions. In other words, each notification emitted by the source Observable is transformed by the operator, which decides what to do with that notification further.

// case 2 - operator stacking with multiple operators(Example: with three operators)
// We can also stack multiple operators together. And once again, we need some source of emissions and then we can apply any number of operators to it. Each operator accepts an input Observable, which is the part above it in the pipeline, and returns an output Observable, which is used by the operators or our Subscription below in the pipeline. So, we can stack and a number of operators. If we would subscribe to the Observable we can see on the screen right now, the 'Operator 3' will run its code first subscribing to 'Operator 2', which will then subscribe to 'Operator 1'. And which will finally subscribe to the actual source of emissions at the top.
// At this point, if the source Observable would emit something, this notification would reach the 'Operator 1' first, then the outcome will be passed to 'Operator 2' and so on. And finally, the notification might reach our Observer. As we have so many operators applied here, it is possible that the set of notifications which will reach our Observer will be completely different from those originally emitted by the source Observable. Summarizing, Pipeable Operators allow us to transform the notifications before they reach our Observer. We can apply as many operators as we want because one operator's output can be another operator's input.
